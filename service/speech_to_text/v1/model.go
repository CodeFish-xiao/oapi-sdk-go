// Package speech_to_text code generated by oapi sdk gen
/*
 * MIT License
 *
 * Copyright (c) 2022 Lark Technologies Pte. Ltd.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice, shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

package larkspeech_to_text

import (
	"github.com/larksuite/oapi-sdk-go/v3/core"
)

type FileConfig struct {
	FileId     *string `json:"file_id,omitempty"`
	Format     *string `json:"format,omitempty"`
	EngineType *string `json:"engine_type,omitempty"`
}

type FileConfigBuilder struct {
	fileId         string
	fileIdFlag     bool
	format         string
	formatFlag     bool
	engineType     string
	engineTypeFlag bool
}

func NewFileConfigBuilder() *FileConfigBuilder {
	builder := &FileConfigBuilder{}
	return builder
}

func (builder *FileConfigBuilder) FileId(fileId string) *FileConfigBuilder {
	builder.fileId = fileId
	builder.fileIdFlag = true
	return builder
}
func (builder *FileConfigBuilder) Format(format string) *FileConfigBuilder {
	builder.format = format
	builder.formatFlag = true
	return builder
}
func (builder *FileConfigBuilder) EngineType(engineType string) *FileConfigBuilder {
	builder.engineType = engineType
	builder.engineTypeFlag = true
	return builder
}

func (builder *FileConfigBuilder) Build() *FileConfig {
	req := &FileConfig{}
	if builder.fileIdFlag {
		req.FileId = &builder.fileId

	}
	if builder.formatFlag {
		req.Format = &builder.format

	}
	if builder.engineTypeFlag {
		req.EngineType = &builder.engineType

	}
	return req
}

type Speech struct {
	Speech    *string `json:"speech,omitempty"`
	SpeechKey *string `json:"speech_key,omitempty"`
}

type SpeechBuilder struct {
	speech        string
	speechFlag    bool
	speechKey     string
	speechKeyFlag bool
}

func NewSpeechBuilder() *SpeechBuilder {
	builder := &SpeechBuilder{}
	return builder
}

func (builder *SpeechBuilder) Speech(speech string) *SpeechBuilder {
	builder.speech = speech
	builder.speechFlag = true
	return builder
}
func (builder *SpeechBuilder) SpeechKey(speechKey string) *SpeechBuilder {
	builder.speechKey = speechKey
	builder.speechKeyFlag = true
	return builder
}

func (builder *SpeechBuilder) Build() *Speech {
	req := &Speech{}
	if builder.speechFlag {
		req.Speech = &builder.speech

	}
	if builder.speechKeyFlag {
		req.SpeechKey = &builder.speechKey

	}
	return req
}

type StreamConfig struct {
	StreamId   *string `json:"stream_id,omitempty"`
	SequenceId *int    `json:"sequence_id,omitempty"`
	Action     *int    `json:"action,omitempty"`
	Format     *string `json:"format,omitempty"`
	EngineType *string `json:"engine_type,omitempty"`
}

type StreamConfigBuilder struct {
	streamId       string
	streamIdFlag   bool
	sequenceId     int
	sequenceIdFlag bool
	action         int
	actionFlag     bool
	format         string
	formatFlag     bool
	engineType     string
	engineTypeFlag bool
}

func NewStreamConfigBuilder() *StreamConfigBuilder {
	builder := &StreamConfigBuilder{}
	return builder
}

func (builder *StreamConfigBuilder) StreamId(streamId string) *StreamConfigBuilder {
	builder.streamId = streamId
	builder.streamIdFlag = true
	return builder
}
func (builder *StreamConfigBuilder) SequenceId(sequenceId int) *StreamConfigBuilder {
	builder.sequenceId = sequenceId
	builder.sequenceIdFlag = true
	return builder
}
func (builder *StreamConfigBuilder) Action(action int) *StreamConfigBuilder {
	builder.action = action
	builder.actionFlag = true
	return builder
}
func (builder *StreamConfigBuilder) Format(format string) *StreamConfigBuilder {
	builder.format = format
	builder.formatFlag = true
	return builder
}
func (builder *StreamConfigBuilder) EngineType(engineType string) *StreamConfigBuilder {
	builder.engineType = engineType
	builder.engineTypeFlag = true
	return builder
}

func (builder *StreamConfigBuilder) Build() *StreamConfig {
	req := &StreamConfig{}
	if builder.streamIdFlag {
		req.StreamId = &builder.streamId

	}
	if builder.sequenceIdFlag {
		req.SequenceId = &builder.sequenceId

	}
	if builder.actionFlag {
		req.Action = &builder.action

	}
	if builder.formatFlag {
		req.Format = &builder.format

	}
	if builder.engineTypeFlag {
		req.EngineType = &builder.engineType

	}
	return req
}

type FileRecognizeSpeechReqBodyBuilder struct {
	speech     *Speech
	speechFlag bool
	config     *FileConfig
	configFlag bool
}

func NewFileRecognizeSpeechReqBodyBuilder() *FileRecognizeSpeechReqBodyBuilder {
	builder := &FileRecognizeSpeechReqBodyBuilder{}
	return builder
}

func (builder *FileRecognizeSpeechReqBodyBuilder) Speech(speech *Speech) *FileRecognizeSpeechReqBodyBuilder {
	builder.speech = speech
	builder.speechFlag = true
	return builder
}
func (builder *FileRecognizeSpeechReqBodyBuilder) Config(config *FileConfig) *FileRecognizeSpeechReqBodyBuilder {
	builder.config = config
	builder.configFlag = true
	return builder
}

func (builder *FileRecognizeSpeechReqBodyBuilder) Build() *FileRecognizeSpeechReqBody {
	req := &FileRecognizeSpeechReqBody{}
	if builder.speechFlag {
		req.Speech = builder.speech
	}
	if builder.configFlag {
		req.Config = builder.config
	}
	return req
}

type FileRecognizeSpeechPathReqBodyBuilder struct {
	speech     *Speech
	speechFlag bool
	config     *FileConfig
	configFlag bool
}

func NewFileRecognizeSpeechPathReqBodyBuilder() *FileRecognizeSpeechPathReqBodyBuilder {
	builder := &FileRecognizeSpeechPathReqBodyBuilder{}
	return builder
}
func (builder *FileRecognizeSpeechPathReqBodyBuilder) Speech(speech *Speech) *FileRecognizeSpeechPathReqBodyBuilder {
	builder.speech = speech
	builder.speechFlag = true
	return builder
}
func (builder *FileRecognizeSpeechPathReqBodyBuilder) Config(config *FileConfig) *FileRecognizeSpeechPathReqBodyBuilder {
	builder.config = config
	builder.configFlag = true
	return builder
}

func (builder *FileRecognizeSpeechPathReqBodyBuilder) Build() (*FileRecognizeSpeechReqBody, error) {
	req := &FileRecognizeSpeechReqBody{}
	if builder.speechFlag {
		req.Speech = builder.speech
	}
	if builder.configFlag {
		req.Config = builder.config
	}
	return req, nil
}

type FileRecognizeSpeechReqBuilder struct {
	apiReq *larkcore.ApiReq
	body   *FileRecognizeSpeechReqBody
}

func NewFileRecognizeSpeechReqBuilder() *FileRecognizeSpeechReqBuilder {
	builder := &FileRecognizeSpeechReqBuilder{}
	builder.apiReq = &larkcore.ApiReq{
		PathParams:  larkcore.PathParams{},
		QueryParams: larkcore.QueryParams{},
	}
	return builder
}

func (builder *FileRecognizeSpeechReqBuilder) Body(body *FileRecognizeSpeechReqBody) *FileRecognizeSpeechReqBuilder {
	builder.body = body
	return builder
}

func (builder *FileRecognizeSpeechReqBuilder) Build() *FileRecognizeSpeechReq {
	req := &FileRecognizeSpeechReq{}
	req.apiReq = &larkcore.ApiReq{}
	req.apiReq.Body = builder.body
	return req
}

type FileRecognizeSpeechReqBody struct {
	Speech *Speech     `json:"speech,omitempty"`
	Config *FileConfig `json:"config,omitempty"`
}

type FileRecognizeSpeechReq struct {
	apiReq *larkcore.ApiReq
	Body   *FileRecognizeSpeechReqBody `body:""`
}

type FileRecognizeSpeechRespData struct {
	RecognitionText *string `json:"recognition_text,omitempty"`
}

type FileRecognizeSpeechResp struct {
	*larkcore.ApiResp `json:"-"`
	larkcore.CodeError
	Data *FileRecognizeSpeechRespData `json:"data"`
}

func (resp *FileRecognizeSpeechResp) Success() bool {
	return resp.Code == 0
}

type StreamRecognizeSpeechReqBodyBuilder struct {
	speech     *Speech
	speechFlag bool
	config     *StreamConfig
	configFlag bool
}

func NewStreamRecognizeSpeechReqBodyBuilder() *StreamRecognizeSpeechReqBodyBuilder {
	builder := &StreamRecognizeSpeechReqBodyBuilder{}
	return builder
}

func (builder *StreamRecognizeSpeechReqBodyBuilder) Speech(speech *Speech) *StreamRecognizeSpeechReqBodyBuilder {
	builder.speech = speech
	builder.speechFlag = true
	return builder
}
func (builder *StreamRecognizeSpeechReqBodyBuilder) Config(config *StreamConfig) *StreamRecognizeSpeechReqBodyBuilder {
	builder.config = config
	builder.configFlag = true
	return builder
}

func (builder *StreamRecognizeSpeechReqBodyBuilder) Build() *StreamRecognizeSpeechReqBody {
	req := &StreamRecognizeSpeechReqBody{}
	if builder.speechFlag {
		req.Speech = builder.speech
	}
	if builder.configFlag {
		req.Config = builder.config
	}
	return req
}

type StreamRecognizeSpeechPathReqBodyBuilder struct {
	speech     *Speech
	speechFlag bool
	config     *StreamConfig
	configFlag bool
}

func NewStreamRecognizeSpeechPathReqBodyBuilder() *StreamRecognizeSpeechPathReqBodyBuilder {
	builder := &StreamRecognizeSpeechPathReqBodyBuilder{}
	return builder
}
func (builder *StreamRecognizeSpeechPathReqBodyBuilder) Speech(speech *Speech) *StreamRecognizeSpeechPathReqBodyBuilder {
	builder.speech = speech
	builder.speechFlag = true
	return builder
}
func (builder *StreamRecognizeSpeechPathReqBodyBuilder) Config(config *StreamConfig) *StreamRecognizeSpeechPathReqBodyBuilder {
	builder.config = config
	builder.configFlag = true
	return builder
}

func (builder *StreamRecognizeSpeechPathReqBodyBuilder) Build() (*StreamRecognizeSpeechReqBody, error) {
	req := &StreamRecognizeSpeechReqBody{}
	if builder.speechFlag {
		req.Speech = builder.speech
	}
	if builder.configFlag {
		req.Config = builder.config
	}
	return req, nil
}

type StreamRecognizeSpeechReqBuilder struct {
	apiReq *larkcore.ApiReq
	body   *StreamRecognizeSpeechReqBody
}

func NewStreamRecognizeSpeechReqBuilder() *StreamRecognizeSpeechReqBuilder {
	builder := &StreamRecognizeSpeechReqBuilder{}
	builder.apiReq = &larkcore.ApiReq{
		PathParams:  larkcore.PathParams{},
		QueryParams: larkcore.QueryParams{},
	}
	return builder
}

func (builder *StreamRecognizeSpeechReqBuilder) Body(body *StreamRecognizeSpeechReqBody) *StreamRecognizeSpeechReqBuilder {
	builder.body = body
	return builder
}

func (builder *StreamRecognizeSpeechReqBuilder) Build() *StreamRecognizeSpeechReq {
	req := &StreamRecognizeSpeechReq{}
	req.apiReq = &larkcore.ApiReq{}
	req.apiReq.Body = builder.body
	return req
}

type StreamRecognizeSpeechReqBody struct {
	Speech *Speech       `json:"speech,omitempty"`
	Config *StreamConfig `json:"config,omitempty"`
}

type StreamRecognizeSpeechReq struct {
	apiReq *larkcore.ApiReq
	Body   *StreamRecognizeSpeechReqBody `body:""`
}

type StreamRecognizeSpeechRespData struct {
	StreamId        *string `json:"stream_id,omitempty"`
	SequenceId      *int    `json:"sequence_id,omitempty"`
	RecognitionText *string `json:"recognition_text,omitempty"`
}

type StreamRecognizeSpeechResp struct {
	*larkcore.ApiResp `json:"-"`
	larkcore.CodeError
	Data *StreamRecognizeSpeechRespData `json:"data"`
}

func (resp *StreamRecognizeSpeechResp) Success() bool {
	return resp.Code == 0
}
