// Package event code generated by oapi sdk gen
package larkevent

import (
	"fmt"

	"context"
	"errors"

	"github.com/larksuite/oapi-sdk-go/v3/core"
)

// 生成枚举值

// 生成数据类型

// 生成请求和响应结果类型，以及请求对象的Builder构造器

// 1.4 生成请求的builder结构体
type ListOutboundIpReqBuilder struct {
	httpReq *larkcore.HttpReq
	limit   int
}

// 生成请求的New构造器
func NewListOutboundIpReqBuilder() *ListOutboundIpReqBuilder {
	builder := &ListOutboundIpReqBuilder{}
	builder.httpReq = &larkcore.HttpReq{
		PathParams:  larkcore.PathParams{},
		QueryParams: larkcore.QueryParams{},
	}
	return builder
}

// 1.5 生成请求的builder属性方法
func (builder *ListOutboundIpReqBuilder) Limit(limit int) *ListOutboundIpReqBuilder {
	builder.limit = limit
	return builder
}
func (builder *ListOutboundIpReqBuilder) PageSize(pageSize int) *ListOutboundIpReqBuilder {
	builder.httpReq.QueryParams.Set("page_size", fmt.Sprint(pageSize))
	return builder
}
func (builder *ListOutboundIpReqBuilder) PageToken(pageToken string) *ListOutboundIpReqBuilder {
	builder.httpReq.QueryParams.Set("page_token", fmt.Sprint(pageToken))
	return builder
}

// 1.5 生成请求的builder的build方法
func (builder *ListOutboundIpReqBuilder) Build() *ListOutboundIpReq {
	req := &ListOutboundIpReq{}
	req.httpReq = &larkcore.HttpReq{}
	req.Limit = builder.limit
	req.httpReq.QueryParams = builder.httpReq.QueryParams
	return req
}

type ListOutboundIpReq struct {
	httpReq *larkcore.HttpReq
	Limit   int
}

type ListOutboundIpRespData struct {
	IpList    []string `json:"ip_list,omitempty"`
	PageToken *string  `json:"page_token,omitempty"`
	HasMore   *bool    `json:"has_more,omitempty"`
}

type ListOutboundIpResp struct {
	*larkcore.RawResponse `json:"-"`
	larkcore.CodeError
	Data *ListOutboundIpRespData `json:"data"`
}

func (resp *ListOutboundIpResp) Success() bool {
	return resp.Code == 0
}

// 生成消息事件结构体

// 生成请求的builder构造器
// 1.1 生成body的builder结构体
type ListOutboundIpIterator struct {
	nextPageToken *string
	items         []string
	index         int
	limit         int
	ctx           context.Context
	req           *ListOutboundIpReq
	listFunc      func(ctx context.Context, req *ListOutboundIpReq, options ...larkcore.RequestOptionFunc) (*ListOutboundIpResp, error)
	options       []larkcore.RequestOptionFunc
	curlNum       int
}

func (iterator *ListOutboundIpIterator) Next() (bool, string, error) {
	// 达到最大量，则返回
	if iterator.limit > 0 && iterator.curlNum >= iterator.limit {
		return false, "", nil
	}

	// 为0则拉取数据
	if iterator.index == 0 || iterator.index >= len(iterator.items) {
		if iterator.index != 0 && iterator.nextPageToken == nil {
			return false, "", nil
		}
		if iterator.nextPageToken != nil {
			iterator.req.httpReq.QueryParams.Set("page_token", *iterator.nextPageToken)
		}
		resp, err := iterator.listFunc(iterator.ctx, iterator.req, iterator.options...)
		if err != nil {
			return false, "", err
		}

		if resp.Code != 0 {
			return false, "", errors.New(fmt.Sprintf("Code:%d,Msg:%s", resp.Code, resp.Msg))
		}

		if len(resp.Data.IpList) == 0 {
			return false, "", nil
		}

		iterator.nextPageToken = resp.Data.PageToken
		iterator.items = resp.Data.IpList
		iterator.index = 0
	}

	block := iterator.items[iterator.index]
	iterator.index++
	iterator.curlNum++
	return true, block, nil
}

func (iterator *ListOutboundIpIterator) NextPageToken() *string {
	return iterator.nextPageToken
}
